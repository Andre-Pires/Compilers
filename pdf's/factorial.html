<HTML>
<HEAD>
<TITLE>factorial</TITLE>
<META NAME="description" CONTENT="factorial">
<META NAME="keywords" CONTENT="factorial">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
</HEAD>
<BODY BGCOLOR="B5BDD6" link=red vlink=green>
  <CENTER> <H1>Linguagem <U>factorial</U></H1>
   <BR> <BR>

  <H2>Manual de Referência</H2>
   <BR>

  <H3>(12 de Fevereiro de 2013)</H3>

</CENTER>
<HR size=2 noshade> <BR>

<BR>
<BR>
<BR>

<P>

<H1><A NAME="intro"> 1 - Introdução</A> </H1>

<P>
Este manual de referência descreve a linguagem de programação <B>factorial</B>.
  Embora procurando ser o mais preciso possível, utiliza-se português
  para descrever a linguagem. Desta forma o documento torna-se mais intuitivo,
  mas menos rigoroso, que uma descrição formal.

<BR>
A linguagem <B>factorial</B> é uma linguagem imperativa, não estruturada,
e fracamente tipificada pois embora possuindo tipos estes podem,
em certos casos, ser misturados.
<DL>
  <DT><STRONG>1.1 - Tipos de dados:</STRONG><DD>
    A linguagem define 3 tipos de dados:
  <DL>
    <DT><STRONG>1.1.1 - números inteiros:</STRONG><DD>
    designados por <TT>integer</TT>, representam números inteiros
    positivos, negativos ou nulos, ocupando 4 bytes em complemento para
    dois, alinhados a 32 bits.
    <DT><STRONG>1.1.2 - cadeias de caracteres:</STRONG><DD>
    designadas por <TT>string</TT>, representam sequências de
    caracteres UTF-8, terminadas
    pelo carácter com o valor 0 ASCII (NULL).
    <DT><STRONG>1.1.3 - números reais:</STRONG><DD>
    designados por <TT>number</TT>, representam números reais em
    vírgula flutuante com 64 bits e devendo ser alinhado a 32 bits.
  </DL>
  <DT><STRONG>1.2 - Verificação de tipos:</STRONG><DD>
    Na linguagem <B>factorial</B> as operações
    dependem dos tipos de dados a que são aplicadas.
    Os tipos suportados por cada operador e a operação a 
    realizar são indicados na definição das
    expressões (ver secção 6).<BR>
  <DT><STRONG>1.3 - Manipulação de nomes:</STRONG><DD>
    Os nomes são usados para designar as entidades de um programa
    em <B>factorial</B>, ou seja, constantes, variáveis e
    funções.
  <DL>
    <DT><STRONG>1.3.1 - espaços de nomes:</STRONG><DD>
      o espaço de nomes global é único, pelo que um
      nome utilizado para designar uma variável não pode ser
      utilizado para designar constantes ou funções.
    <DT><STRONG>1.3.2 - alcance das variáveis:</STRONG><DD>
      as variáveis globais (declaradas fora de qualquer
      função ou corpo), e as restantes entidades, existem
      do início ao fim da execução do programa.
      As variáveis locais aos corpos existem apenas durante a
      execução destes, e os argumentos formais estão
      válidos enquanto a função está activa.
    <DT><STRONG>1.3.3 - visibilidade dos identificadores:</STRONG><DD>
      os identificadores estão visíveis desde a sua
      declaração até ao fim do seu alcance, ficheiro (globais) ou bloco (locais). A redeclaração de um mesmo identificador num corpo mais interior cria uma nova variável que encobre a anterior até ao fim do respectivo corpo. Uma função não pode declarar no seu corpo principal identificadores com mesmo nome dos seus argumentos formais.
  </DL>
</DL>

<P>

<H1><A NAME="lexical"> 2 - Convenções lexicais</A> </H1>

<P>
A linguagem de programação <B>factorial</B> é constituída por seis grupos de
  elementos léxicais (tokens), devendo o elemento léxical ser
  constituído pela maior sequência de caracteres que constitua um
  elemento lexical válido:

<DL>
    <DT><STRONG>2.1 - Caracteres brancos:</STRONG><DD>
são considerados caracteres brancos aqueles que, embora servindo para
separar os elementos lexicais, não representam nenhum elemento
lexical. São considerados caracteres brancos:
<B>espaço</B> ASCII SP (0x20), <B>mudança de linha</B> ASCII LF (0x0A), <B>recuo do carreto</B> ASCII CR (0x0D) e <B>tabulação horizontal</B> ASCII HT (0x9).

    <DT><STRONG>2.2 - Comentários:</STRONG><DD>
Os comentários funcionam como separadores de elementos lexicais.
Os comentários são iniciados por ('=&lt;') e terminam com ('=&gt;'),
    desde que não façam parte de cadeias de caracteres.
    Estes comentários podem ser aninhados (&nbsp;entalhados ou
    nested&nbsp;), isto é, podem ser colocados uns dentro dos outros.
    Os comentário podem ainda ser iniciados por ('=='), caso em que terminam
    implicitamente no fim da respectiva linha.
    </DL>

    <DT><STRONG>2.3 - Identificadores:</STRONG><DD>
  &nbsp;por vezes designados por nomes&nbsp;, são constituídos por
  uma letra (maiúscula ou minúscula) seguida por 0 (zero) ou mais
  letras, dígitos ou o carácter ('_').
  O número de caracteres que constituem um identificador é ilimitado e
  dois nomes designam identificadores distintos se houver alteração
  de maiúscula para minúscula, ou vice-versa, de pelo menos um
  carácter.
    <DT><STRONG>2.4 - Palavras chave:</STRONG><DD>
os identificadores indicados na tabela abaixo estão reservados pela
  linguagem <B>factorial</B>, são palavras chave da linguagem, e não
  podem ser utilizados como identificadores normais. Estes identificadores
  têm de ser escritos exactamente como na tabela abaixo:
  <TABLE CELLPADDING=3> <TR>
    <TD ALIGN="LEFT">void</TD> <TD ALIGN="LEFT">integer</TD>
    <TD ALIGN="LEFT">string</TD> <TD ALIGN="LEFT">public</TD>
    <TD ALIGN="LEFT">number</TD> <TD ALIGN="LEFT">const</TD>
    <TD ALIGN="LEFT">if</TD> <TD ALIGN="LEFT">then</TD>
    <TD ALIGN="LEFT">else</TD> <TD ALIGN="LEFT">while</TD>
    <TD ALIGN="LEFT">do</TD> <TD ALIGN="LEFT">for</TD>
    <TD ALIGN="LEFT">in</TD> <TD ALIGN="LEFT">step</TD>
    <TD ALIGN="LEFT">upto</TD> <TD ALIGN="LEFT">downto</TD>
    <TD ALIGN="LEFT">break</TD> <TD ALIGN="LEFT">continue</TD>
    </TR>
  </TABLE>
    <DT><STRONG>2.5 - Literais:</STRONG><DD>
são notações para valores constantes de alguns tipos predefinidos
  da linguagem. (Notar que constantes são identificadores que designam
  elementos cujo valor não pode sofrer alterações durante a
  execução do programa.)
    <DL>
    <DT><STRONG>2.5.1 - inteiros:</STRONG> <DD> 
  um literal inteiro, ao contrário de uma constante inteira, é um
  número positivo. (Notar que os números negativos são
  construídos pela aplicação do operador menos unário
  (-) a um literal positivo.)
<BR>
Um literal inteiro em decimal é constituído por uma sequência de
  1 (um) ou mais dígitos decimais (&nbsp;dígitos de '0' a '9'&nbsp;) em que o primeiro
  dígito não é um '0' (zero), excepto no caso do número 0 (zero)
  composto apenas pelo dígito '0' (zero), que é igual qualquer que seja
  a base de numeração.
Um literal inteiro em octal é começa sempre pelo dígito '0' (zero), sendo seguido de um ou mais digitos de '0' a '9'.  Note-se que o número 09 é um inteiro octal válido com valor igual a 011 (octal).
Um literal inteiro em binário é começa sempre pela sequência '0b', sendo seguido de um ou mais digitos '0' ou '1'.
<BR>
Se não for possível representar o literal inteiro na
máquina, devido a um <I>overflow</I>, deverá ser gerado
um erro lexical.
    <DT><STRONG>2.5.2 - cadeia de caracteres:</STRONG> <DD> 
começam e terminam com o carácter aspa (").
  Uma cadeia de texto pode conter qualquer número de caracteres,
  podendo estes ser valores ASCII (excepto o 0 ou NULL) ou caracteres
   ISO-LATIN-15 para caracteres portugueses. Os caracteres utilizados
  para iniciar ou terminar comentários como ('&lt;'), ('&gt;') ou
  ('=') têm o seu valor normal  ASCII não inciando ou
  terminando qualquer comentário.
  O carácter aspa (") pode ser utilizado desde que precedido de (\).
  Os caracteres ASCII LF, CR e HT podem ser presentados pelas sequências
  '\n', '\r' e '\t', respectivamente.
  Qualquer outro carácter pode ser representado por 1 ou 2 digitos
  hexadecimais precedidos do carácter '\', por exemplo '\0a' ou apenas
  '\A' se o carácter seguinte não representar um digito hexadecimal.
    <DT><STRONG>2.5.3 - reais em vírgula flutuante:</STRONG> <DD> 
  O literal real é um número real com partes inteira e decimal obrigatórias separadas por um ponto decimal, além de uma parte exponencial facultativa, tal como definido pela linguagem <B>Pascal</B>.
<BR>
Se não for possível representar o literal na máquina, devido a um <I>overflow</I>, deverá ser gerado um erro lexical.
    </DL>
    <DT><STRONG>2.6 - Operadores de expressões:</STRONG><DD>
são considerados operadores da linguagem <B>factorial</B>
os seguintes elementos lexicais,
<TABLE CELLPADDING=3> <TR>
<TD ALIGN="LEFT"><TT>-</TT></TD> <TD ALIGN="LEFT"><TT>+</TT></TD>
<TD ALIGN="LEFT"><TT>*</TT></TD> <TD ALIGN="LEFT"><TT>/</TT></TD>
<TD ALIGN="LEFT"><TT>%</TT></TD>
<TD ALIGN="LEFT"><TT>&lt;</TT></TD> <TD ALIGN="LEFT"><TT>&gt;</TT></TD>
<TD ALIGN="LEFT"><TT>=</TT></TD> <TD ALIGN="LEFT"><TT>&gt;=</TT></TD>
<TD ALIGN="LEFT"><TT>&lt;=</TT></TD> <TD ALIGN="LEFT"><TT>&lt;&gt;</TT></TD>
<TD ALIGN="LEFT"><TT>:=</TT></TD> <TD ALIGN="LEFT"><TT>++</TT></TD>
<TD ALIGN="LEFT"><TT>--</TT></TD> <TD ALIGN="LEFT"><TT>!</TT></TD>
<TD ALIGN="LEFT"><TT>|</TT></TD> <TD ALIGN="LEFT"><TT>&amp;</TT></TD>
<TD ALIGN="LEFT"><TT>~</TT></TD>
</TR>
</TABLE>
    <DT><STRONG>2.7 - Delimitadores e separadores:</STRONG><DD>
Os elementos lexicais seguintes são considerados delimitadores da linguagem
  <B>factorial</B>: '#', '{', '}', '(', ')', '[', ']', ';', e ',' (vírgula).
  <BR> O carácter '\n' ou <B>mudança de linha</B> ASCII LF (0x0A) funciona
  como o delimitador ';' quando a linha termina com um literal, um identificador
  ou os carracteres ')' ou '!', se a linha não terminar com o carácter ';'.
</DL>

<P>

<H1><A NAME="gram"> 3 - Gramática</A> </H1>

<DL>
  <DT><STRONG>3.1 - Gramática:</STRONG><DD>
A gramática da linguagem <B>factorial</B> pode ser resumida pelas regras
abaixo. Os elementos a negrito são literais, os parênteses curvos agrupam
elementos, elementos alternativos são separados por uma barra vertical,
elemento opcionais estão entre parênteses rectos e os
elementos que se repetem zero ou mais vezes estão entre chavetas.
Cuidado que a barra vertical, os parênteses e as chavetas são
elementos lexicais da linguagem quando representados a negrito.
<TABLE CELLPADDING=3>
<TR><TD ALIGN="RIGHT">ficheiro<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	{ declaração }
<TR><TD ALIGN="RIGHT">declaração<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	[ <B>public</B> ] [ <B>const</B> ] tipo [ <B><FONT SIZE=4>*</FONT></B> ] ident [ init ] <B><FONT SIZE=4>;</FONT></B>
<TR><TD ALIGN="RIGHT">tipo<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	<B>integer</B> | <B>string</B> | <B>number</B> | <B>void</B>
<TR><TD ALIGN="RIGHT">init<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	<B><FONT SIZE=4>:=</FONT></B> inteiro |
	<TR><TD><TD><TD><B><FONT SIZE=4>:=</FONT></B> [ <B>const</B> ] cadeia |
	<TR><TD><TD><TD><B><FONT SIZE=4>:=</FONT></B> real |
	<TR><TD><TD><TD><B><FONT SIZE=4>:=</FONT></B> ident |
	<TR><TD><TD><TD><B><FONT SIZE=4>(</FONT></B> [ parâmetros ] <B><FONT SIZE=4>)</FONT></B> [ corpo ]
<TR><TD ALIGN="RIGHT">parâmetros<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	parâmetro { <B><FONT SIZE=4>,</FONT></B> parâmetro }
<TR><TD ALIGN="RIGHT">parâmetro<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	tipo [ <B><FONT SIZE=4>*</FONT></B> ] ident
<TR><TD ALIGN="RIGHT">corpo<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	<B><FONT SIZE=4>{</FONT></B> { parâmetro <B><FONT SIZE=4>;</FONT></B> } { instrução } <B><FONT SIZE=4>}</FONT></B>
<TR><TD ALIGN="RIGHT">instrução<TD ALIGN="CENTER">=<TD ALIGN="LEFT">
	<B>if</B> expressão <B>then</B> instrução [ <B>else</B> instrução ] |
<TR><TD><TD><TD><B>do</B> expressão <B>while</B> instrução |
	<TR><TD><TD><TD><B>for</B> left-value <B>in</B> expressão ( <B>upto</B> | <B>downto</B> ) expressão [ <B>step</B> expressão ] <B>do</B> instrução |
<TR><TD><TD><TD>expressão <B><FONT SIZE=4>;</FONT></B> |
<TR><TD><TD><TD>corpo |
<TR><TD><TD><TD><B>break</B> inteiro <B><FONT SIZE=4>;</FONT></B> |
<TR><TD><TD><TD><B>continue</B> inteiro <B><FONT SIZE=4>;</FONT></B> |
<TR><TD><TD><TD>left-value <B><FONT SIZE=4>#</FONT></B> expressão <B><FONT SIZE=4>;</FONT></B>
</TR></TABLE>
  <DL>
    <DT><STRONG>3.1.1 - elementos lexicais:</STRONG><DD>
    foram omitidos da gramática, por já terem sido definidos
    acima, os seguintes elementos:
    <DL>
      <DT><STRONG>3.1.1.1 - ident:</STRONG><DD> definido em 2.3
      <DT><STRONG>3.1.1.2 - inteiro:</STRONG><DD> definido em 2.5.1
      <DT><STRONG>3.1.1.3 - cadeia:</STRONG><DD> definido em 2.5.2
      <DT><STRONG>3.1.1.4 - real:</STRONG><DD> definido em 2.5.3
    </DL>
    <DT><STRONG>3.1.2 - expressão:</STRONG><DD>
    foi delibradamente omitida da gramática e será tratada em
    na secção 6.
  </DL>
  <DT><STRONG>3.2 - Constantes:</STRONG><DD>
    A linguagem define 2 tipos de constantes:
  <DL>
    <DT><STRONG>3.2.1 - identificadores constantes:</STRONG><DD>
    sucedem a declaração pela palavra reservada <TT>const</TT>,
    impedindo que o identificador declarado possa ser utilizado em
    operações que modifiquem o seu valor. Caso um identificador
    designe uma constante inteira que não seja <i>public</i>
    (ver adiante) o seu valor poderá ser directamente
    substituído no código, não ocupando espaço. Os identificadores
    declarados constantes que não sejam <i>public</i> têm de ser iniciados.
    <DT><STRONG>3.2.2 - valores constantes:</STRONG><DD>
    são todos os corpos das funções (devido à gestão das
    <I>caches</I> pelos processadores, que não gostam de <I>self-modifying
    code</I>) e os inicializados de strings precedidas pela palavra reservada <TT>const</TT>. Como as funções são sempre constantes a palavra reservada <TT>const</TT> não deve ser utilizada.
  </DL>
  <DT><STRONG>3.3 - Ficheiros:</STRONG><DD>
  Um ficheiro descrito em <B>factorial</B> é constituído por uma sequência
  de declarações.
  <DL>
    <DT><STRONG>3.3.1 - programas:</STRONG><DD>
    a execução de um programa exige uma só função pública <TT>entry</TT>.
    Assim, nos diversos ficheiros que podem constituir um programa em
    <B>factorial</B> apenas um deles terá de incluir uma função com a
    assinatura: <TT> public integer entry ( integer argc, string *argv )</TT>
  </DL>
  <DT><STRONG>3.4 - Símbolos globais:</STRONG><DD>
    Para a utilização de compilação separada em
    <B>factorial</B> existe a palavra reservada <TT>public</TT>
    que torna o símbolo visível de/para outros ficheiros.
  <DL>
    <DT><STRONG>3.4.1 - importação:</STRONG><DD>
    um símbolo declarado <TT>public</TT> mas não iniciado é considerado
    exterior e tratado como pertencente a outro módulo.
    <DT><STRONG>3.4.2 - exportação:</STRONG><DD>
    um símbolo declarado <TT>public</TT> e iniciado é considerado
    global e tratado como podendo ser acedido de outros módulos.
    <DT><STRONG>3.4.3 - declaração por avanço (<I>forward declaration</I>):</STRONG><DD>
    um símbolo que não é declarado <TT>public</TT> e não é iniciado é
    considerado como declarado por avanço devendo ficar completamente
    definido posteriormente no mesmo ficheiro.
  </DL>
  <DT><STRONG>3.5 - Declaração de variáveis e constantes:</STRONG><DD>
    cada declaração permite declarar uma única variável
    ou constante.
    Uma declaração inclui os seguintes componentes:
    <DL>
    <DT><STRONG>3.5.1 - constante:</STRONG><DD>
    designada pela palavra reservada <TT>const</TT>,
    que torna o identificador constante, ou seja, cujo valor representado
    não pode ser modificado. Tal não significa que os valores
    indirectamente referidos (apontados) pelo identidicador sejam constantes.
    <DT><STRONG>3.5.2 - tipo de dados:</STRONG><DD>
    designado por um dos 3 tipos de dados (<TT>integer</TT>, <TT>string</TT>
    ou <TT>number</TT>).
    <DT><STRONG>3.5.3 - identificador:</STRONG><DD>
    designada por um identificador que passa a nomear a entidade declarada.
    <DT><STRONG>3.5.4 - ponteiro:</STRONG><DD>
    designado por <TT>*</TT> permite referir posições de memória contendo dados to tipo base.
    <DT><STRONG>3.5.5 - inicialização:</STRONG><DD>
    a existir inicia-se com o operador de atribuição ':='
    seguido de valores constantes dependentes do tipo declarado:
      <DL>
      <DT><STRONG>3.5.5.1 - inteiros:</STRONG><DD>
      o valor a iniciar é um número inteiro, representado em decimal, octal ou binário.
      <DT><STRONG>3.5.5.2 - cadeia de caracteres:</STRONG><DD>
      a cadeia é constante se for precedida da palavra reservada <TT>const</TT>
      e variável em caso contrário, independentemente do
      identificador que a refer ser constante ou não. Notar que o identificador
      de uma cadeia de caracteres é sempre um ponteiro e nunca um vector, pelo
      pode ser constante ou não.
      <DT><STRONG>3.5.5.3 - reais:</STRONG><DD>
      o valor a iniciar é um número real representado em vírgula flutuante tal
      como definido em 2.5.3.
      <DT><STRONG>3.5.5.4 - identificadores:</STRONG><DD>
      caso o identificador seja um ponteiro, o seu valor pode ser iniciado com
      um outro identificador do mesmo tipo base.
      <DT><STRONG>3.5.5.5 - funções:</STRONG><DD>
      ver secção 4.
      </DL>
    </DL>
    Notar que declarações de constantes não iniciadas
    só é possível se forem identificadores importados.
  </DL>
</DL>

<P>

<H1><A NAME="func"> 4 - Funções</A> </H1>

<P>
Uma função permite agrupar um conjunto de instruções
num corpo, que é executado com base num conjunto de parâmetros
( os argumentos formais ) quando é invocada a partir de uma
expressão.
<DL>
  <DT><STRONG>4.1 - Declaração :</STRONG><DD>
  As funções em <B>factorial</B> são sempre designadas por identificadores
  constantes precedidos do tipo de dados devolvido pela função e de uma
  lista de argumentos formais delimitados por parêntesis. <BR>
    As funções, que recebam argumentos, devem indicá-los no cabeçalho.
    Rotinas que não devolvem qualquer valor são declaradas do tipo <TT>void</TT>.
    <BR>
    Uma declaração de uma função não  iniciada é utilizada para
    tipificar um identificador importado (quando público) ou para efectuar
    <I>forward declarations</I> (utilizada para pré-declarar uma função
    que seja usada antes de ser definida, por exemplo, entre duas
    funções mutuamente recursivas).
    Uma declaração de uma função iniciada define uma nova função constituída
    pelo corpo que a inicia.
    <BR>
    O valor devolvido por uma função é mantido numa variável com o mesmo nome
    da função e que é implicitamente declarado, caso a função não seja do
    tipo <TT>void</TT>.
    <BR>
    O corpo da função, designado por bloco principal, não pode
    definir variáveis  designadas por identificadores com o mesmo nome
    de nenhum dos argumentos formais da função. Nem os argumentos formais nem
    nenhum dos blocos da função pode declarar variáveis
    com o nome da própria função.
  <DT><STRONG>4.2 - Invocação :</STRONG><DD>
    A função só pode ser invocada através de um identificador
    que refira uma função previamente declarada ou definida.
    <BR>
    Caso existam argumentos, na invocação da função
    o seu identificador é seguido de uma lista de expressões
    delimitadas por parenteses curvos.
    A lista de expressões é uma sequência de expressões separadas por vírgulas.
    As expressões são avaliadas da direita para a esquerda antes da
    invocação da função e o valor resultante passado por
    cópia (&nbsp;passagem de argumentos por valor&nbsp;). <BR>
    O tipo e número de parâmetros actuais deve ser igual ao tipo e número de
    parâmetros formais.
    A ordem dos parâmetros actuais deverá ser a mesma dos argumentos
    formais da função a ser invocada.
    Os parâmetros actuais devem
    ser colocados na pilha de dados pela ordem inversa da sua
    declaração (&nbsp;o primeiro no topo da pilha&nbsp;) e
    o endereço de retorno no topo da pilha. <BR>
    Quem coloca os argumentos na pilha (&nbsp;a função
    chamadora&nbsp;) também é responsável pela sua
    remoção após o retorno da função chamada
    (&nbsp;chamada <I>à lá</I> C&nbsp;).
  <DT><STRONG>4.3 - Corpo :</STRONG><DD>
    O corpo, quer seja o bloco principal de uma função ou
    um sub-bloco de uma instrução condicional ou de
    iteração, pode definir apenas variáveis não
    iniciadas. 
</DL>

<P>

<H1><A NAME="instr"> 5 - Instruções</A> </H1>

<P>
Excepto quando indicado as instruções são executadas em
sequência, sendo os seus efeitos traduzidos, em geral,
pela alteração do valor de variáveis.
<DL>
  <DT><STRONG>5.1 - Instrução condicional:</STRONG><DD>
  Se a expressão que segue a palavra reservada <B>if</B> for diferente
  de 0 (zero) então a instrução que segue a palavra reservada <B>then</B>
  é executada. <BR>
  Caso exista um conjunto <B>else</B>, a instrução é executada quando
  a expressão que segue a palavra reservada <B>if</B> tem o valor 0 (zero). 
  <DT><STRONG>5.2 - Instrução de iteração por valor:</STRONG><DD>
  A instrução que segue a palavra reservada <B>do</B>, sendo a sua
  execução repetida enquanto a expressão que segue a palavra resrvada
  <B>while</B> for diferente de 0 (zero).
  <BR>
  <DT><STRONG>5.3 - Instrução de iteração por contagem:</STRONG><DD>
  iniciada pela palavra reservada <TT>for</TT>,
  deve começar por atribuir ao <TT>left-value</TT> 
  o resultado da expressão que segue palavra reservada <TT>in</TT>.
  A instrução do ciclo é sucessivamente repetida até o valor do
  <TT>left-value</TT> ser superior (<TT>upto</TT>) ou inferior (<TT>downto</TT>)
  ao valor da expressão que segue as palavras reservadas <TT>upto</TT> e
  <TT>downto</TT>.
  Se existir a expressão que segue a palavra reservada <TT>step</TT>, o 
  <TT>left-value</TT> deverá ser incrementado (<TT>upto</TT>) ou
  decrementado (<TT>downto</TT>) do seu valor, caso contrário o valor deve ser
  considerado unitário.
  <DT><STRONG>5.4 - Expressção como instrução:</STRONG><DD>
  qualquer expressão pode ser utilizada como instrução,
  mesmo que não produza qualquer efeito secundário.
  <DT><STRONG>5.5 - Corpo como instrução:</STRONG><DD>
  um corpo pode substituir uma instrução, permitindo a execução sequencial
  de mais de uma instrução em seu lugar.
  <DT><STRONG>5.6 - Instrução de continuação:</STRONG><DD>
  iniciada pela palavra reservada <TT>continue</TT>,
  a existir deverá ser a última instrução do bloco
  em que se insere. Esta instrução reinicia uma instrução
  de iteração, ignorando tantos ciclos quantos o valor constante
  inteiro positivo que se lhe segue subtraído de uma unidade.
  Deve ser considerado o valor unitário, caso o valor inteiro seja omitido.
  <BR>
  Assim, <TT>continue 3</TT> ignora o ciclo mais interior e o seguinte,
  reiniciando a execução na avaliação da expressão do
  terceiro ciclo mais interior, enquanto <TT>continue 1</TT> reinicia o
  próprio ciclo tal como a instrução <TT>continue</TT>.
  Esta instrução só pode existir dentro de um ciclo.
  <DT><STRONG>5.7 - Instrução de terminação:</STRONG><DD>
  iniciada pela palavra reservada <TT>break</TT>,
  a existir deverá ser a última instrução do bloco
  em que se insere. Esta instrução termina a execução
  de tantos ciclos quantos o valor constante inteiro positivo que se lhe segue.
  Deve ser considerado o valor unitário, caso o valor inteiro seja omitido.
  <BR>
  Esta instrução só pode existir dentro de um ciclo,
  devendo o número de ciclo aninhados ser igual ou inferior ao
  valor constante inteiro positivo que se lhe segue. <BR>
  Quando esta instrção é executada, os conjuntos <B>else</B>
  associados aos ciclos terminados não são executados.
  <DT><STRONG>5.8 - Reserva de memória na pilha</STRONG><DD>
  A instrução de reserva de memória na pilha permite que numa
  função se reserve uma quantidade de memória variável.
</DL>


<P>

<H1><A NAME="expr"> 6 - Expressões</A> </H1>


<P>
Uma expressão é uma representação algébrica de uma quantidade.
  Assim, todas as expressões devolvem um valor.
  As expressões na linguagem de programação <B>factorial</B> utilizam
  operadores algébricos comuns: soma, subtracção,
  multiplicação e divisão inteira e resto da divisão,
  além de outros operadores.

<BR>
As expressões são sempre avaliadas da esquerda para a
  direita, independentemente da associatividade do operador.
  A precedência dos operadores é a mesma para operadores na mesma
  secção, sendo as secções seguintes de menor prioridade que as
  anteriores. O valor resultante da aplicação da expressão bem
  como a sua associatividade são descriminados em cada operador.
<BR>

A tabela seguinte que resume os operadores da
  linguagem <B>factorial</B>, por grupos de precedência decrescente:
<BR>
<BLOCKQUOTE> <BLOCKQUOTE> <BLOCKQUOTE>
<TABLE border>
<TR><TH> designação <TH align="center"> operadores <TH> associatividade
<TR><TD>primária <TD align="center"> ( ) [ ] <TD> não associativos
<TR><TD>unária   <TD align="center"> * &amp; ! - ++ --  <TD> não associativos    
<TR><TD>multiplicativa  <TD align="center"> * / %     <TD> da esquerda para a direita
<TR><TD>aditiva         <TD align="center"> + -       <TD> da esquerda para a direita
<TR><TD>comparativa     <TD align="center"> &lt; &gt; &lt;= &gt;= <TD> da esquerda para a direita
<TR><TD>igualdade       <TD align="center"> = &lt;&gt;<TD> da esquerda para a direita
<TR><TD><TT>`não'</TT> lógico <TD align="center"> ~   <TD> não associativo
<TR><TD><TT>`e'</TT> lógico <TD align="center"> &amp; <TD> da esquerda para a direita
<TR><TD><TT>`ou'</TT> lógico <TD align="center"> |    <TD> da esquerda para a direita
<TR><TD>atribuição<TD align="center"> := <TD> da direita para a esquerda
</TABLE>
</BLOCKQUOTE> </BLOCKQUOTE> </BLOCKQUOTE>
Os operadores têm o mesmo significado que em <B>C</B>, com a
excepção do operador de comparação (que usa <B>&lt;&gt;</B>
em vez de <B>!=</B>) e do operador factorial (que usa <B>!</B>),
  como noutras linguagens de programação.
<P>
<DL>
  <DT><STRONG>6.1 - Expressões primárias:</STRONG><DD>
  <DL>
    <DT><STRONG>6.1.1 - identificadores:</STRONG><DD>
    Um identificador é uma expressão desde que tenha sido
    devidamente declarado. Um identificador pode denotar uma variável ou
    uma constante.
    <BR>
    Um identificador é o caso mais simples de um <I>left-value</I>, ou
    seja, uma entidade que pode ser utilizada no lado esquerdo (<I>left-
    value</I>) de uma atribuição.
    <DT><STRONG>6.1.2 - literais:</STRONG><DD>
    Os literais podem ser valores constantes inteiros ou reais não negativos,
    tal como definidos nas convenções lexicais, ou cadeias
    de caracteres.
    <DT><STRONG>6.1.3 - parenteses curvos:</STRONG><DD>
    Uma expressão entre parenteses curvos tem o valor da expressão
    sem os parenteses e permite alterar a prioridade dos operadores.
    Uma expressão entre parenteses não pode ser utilizada como
    <I>left-value</I> (&nbsp;ver em indexação&nbsp;).
    <DT><STRONG>6.1.4 - indexa&#231;&#227;o:</STRONG><DD>
    Uma express&#227;o indexa&#231;&#227;o  referencia uma entidade
    atrav&#233;s da sua localiza&#231;&#227;o em mem&#243;ria.
    O identificador dever&#225; designar apenas uma vari&#225;vel ou
    constante do tipo ponteiro. <BR>
    O resultado de uma express&#227;o de indexa&#231;&#227;o &#233;
    o valor existente na posi&#231;&#227;o de mem&#243;ria indicada
    pelo identificador somado com o deslocamento, em quantidades da
    dimens&#227;o do tipo base, do valor da express&#227;o.
    A indexação de cadeias de caracteres é o valor inteiro correspondente ao
    carácter.
    O deslocamento &#233; calculado, <I>``&#224; la C''</I>, em que o
    primeiro elemento tem deslocamento 0 (zero), ou seja, base[0]. <BR>
    Uma indexa&#231;&#227;o tamb&eacute;m pode ser
    utilizada como <I>left-value</I>.
    <DT><STRONG>6.1.5 - invocação:</STRONG><DD>
    A função só pode ser invocada através de um
    identificador que refira uma função previamente declarada
    ou definida. Variáveis ou constantes do tipo <tt>void *</tt>
    referem funções, podendo ser directamente utilizadas na invocação
    da função para que apontam. O número e tipo de argumentos deve ser igual,
    não havendo lugar a conversões implícitas de tipos.<BR>
  </DL>
  <DT><STRONG>6.2 - Expressões unárias:</STRONG><DD>
  <DL>
    <DT><STRONG>6.2.1 - localização:</STRONG><DD>
    A expressão localização devolve a posição de
    memória ocupada pelo <I>left-value</I>. É possível obter a
    localização de uma função utilizando o seu nome sem parenteses.
    <DT><STRONG>6.2.2 - indireção:</STRONG><DD>
    A expressão de indireção devolve o conteúdo da posição de memória
    indicada pela expressão.
    <DT><STRONG>6.2.3 - simétrico:</STRONG><DD>
    A expressão valor simétrico devolve o simétrico do valor
    inteiro ou real.
    <DT><STRONG>6.2.4 - factorial:</STRONG><DD>
    A expressão factorial devolve o valor real do factorial de um valor
    inteiro positivo, ou o valor unitário se o argumento não for positivo.
    <DT><STRONG>6.2.5 - incremento e decremento:</STRONG><DD>
    as operações de incremento e decremento só podem
    ser aplicadas a <I>left-values</I> do tipo inteiro.
    A operação modifica o valor designado de tal forma que este
    passe a referir o elemento seguinte ou anterior, dependendo de se tratar
    de incremento ou decremento, respectivamente.
    O valor devolvido pela operação corresponde ao valor
    do <I>left-value</I> no momento da avaliação da
    expressão.
    Cada operação de pré incremento ou decremento é
    efectuada antes do cálculo do respectivo <I>left-value</I>.
    Cada operação de pós incremento ou decremento é
    efectuada depois do cálculo do respectivo <I>left-value</I>.

  </DL>
  <DT><STRONG>6.3 - Expressões multiplicativas:</STRONG><DD>
  as operações são apenas aplicáveis a valores inteiros ou reais,
  devolvendo o resultado da respectiva operação algébrica.
  <DT><STRONG>6.4 - Expressões aditivas:</STRONG><DD>
  as operações são apenas aplicáveis a valores inteiros ou reais,
  devolvendo o resultado da respectiva operação algébrica.
  <DT><STRONG>6.5 - Expressões de grandeza:</STRONG><DD>
  as operações são aplicáveis a valores inteiros ou reais,
  devolvendo o valor inteiro 0 (zero) caso seja falsa e 1 (um) caso
  contrário, a cadeias de caracteres, devolvendo o resultado da sua
  comparação alfabética segundo o código ASCII (
  logo 'A' é diferente de 'a' ).
  <DT><STRONG>6.6 - Expressões de igualdade:</STRONG><DD>
  as operações são aplicáveis a valores inteiros ou reais
  e a cadeias de caracteres, tal como no caso anterior.
  <DT><STRONG>6.7 - Expressões de negação lógica:</STRONG><DD>
  a operação é aplicável a valores inteiros,
  devolvendo o valor inteiro 0 (zero) caso o argumento seja diferente de
  0 (zero) e 1 (um) caso contrário.
  <DT><STRONG>6.8 - Expressões de junção lógica:</STRONG><DD>
  a operação é aplicável a valores inteiros,
  devolvendo o valor inteiro 1 (um) caso ambos os argumentos sejam
  diferente de 0 (zero) e 1 (um) caso contrário.
  Caso o primeiro argumento seja 0 (zero) o segundo argumento não
  deve ser avaliado.
  <DT><STRONG>6.9 - Expressões de alternativa lógica:</STRONG><DD>
  a operação é aplicável a valores inteiros,
  devolvendo o valor inteiro 0 (zero) caso ambos os argumentos sejam
  iguais a 0 (zero) e 1 (um) caso contrário.
  Caso o primeiro argumento seja 1 (um) o segundo argumento não
  deve ser avaliado.
  <DT><STRONG>6.10 - Expressões de atribuição:</STRONG><DD>
  O valor da expressão do lado direito do operador é
  guardado na posição indicada pelo <I>left-value</I> do 
  lado direito do operador de atribuição.

</DL>

<P>

<H1><A NAME="main"> 7 - Interface com o sistema operativo</A> </H1>

<P>
<DL>
  <DT><STRONG>7.1 - Função principal:</STRONG><DD>
A execução de um programa em <B>factorial</B> inicia-se com a
invocação da função:
<PRE>
public integer entry (integer argc, string *argv, string *envp);
</PRE>
  O primeiro argumento representa o número de argumentos indicados
  na linha de comando, incluindo o nome do programa.
  Os segundo e terceiro argumentos são sequências de cadeias de caracteres
  que correspondem ao valor dos argumentos e das variáveis de ambiente,
  respectivamente.
  O valor de retorno desta função é devolvido ao sistema
  operativo que invocou o programa. Assim, o valor de retorno da
  função segue as regras do sistema operativo, ou seja, 0 (zero)
  se a execução correu sem erros, 1 (um) se os argumentos são
  em número ou valor inválido, 2 (dois) erro detectado durante
  a execução. Os valores superiores a 128 indicam
  que o programa terminou com uma interrupção.
  Para que muitos programas funcionem correctamente exige-se que todas
  as ferramentas, e programas desenvolvidos, devolvam 0 (zero) se a
  execução correu sem problemas e um valor diferente
  de 0 (zero) se existiu um erro.
  </DL>
  <DT><STRONG>7.2 - rotinas de biblioteca:</STRONG><DD>
  O ficheiro <B>linux.asm</B> contém a rotina de
  arranque (<TT>_start</TT>) que invoca a rotina de entrada (<TT>entry</TT>)
  para os programas desenvolvidos em <B>factorial</B>,
  bem como a rotina de terminação (<TT>_exit</TT>).
  O ficheiro <B>lib.asm</B> contém
  um conjunto de rotinas de biblioteca que poderá utilizar, com
  nomes auto-explicativos e semelhantes aos da biblioteca de <B>C</B>:
  println, printsp, prints, printi, readln, readb, readi, strlen, atoi e
  itoa.
  O ficheiro <B>dbl.c</B> contém rotinas de leitura, escrita e conversão de números reais representados em vírgula flutuante: readd, readr, printd, printr, atod, atof, dtoa e dtof. 
  Deverão igualmente ser adicionadas quaisquer rotinas necessárias ao correcto
  funcionamento dos operadores existentes na linguagem.
  <DT><STRONG>7.3 - chamadas ao sistema operativo:</STRONG><DD>
  O ficheiro <B>sys.asm</B> contém as chamadas ao sistema que pode
  realizar em programas escritos em <B>factorial</B>.
  Uma explicação das chamadas ao sistema pode ser obtida
  através de:
  <PRE>
  <TT>prompt$</TT> <I>man 2 intro</I>
  <TT>prompt$</TT> <I>man 2 syscalls</I>
  </PRE>
  Algumas destas chamadas não existem na biblioteca de <B>C</B>,
  outras, como o <B>brk</B>, têm um comportamente diferente da
  rotina homónima da biblioteca de <B>C</B>.
</DL>
<P>

<H1><A NAME="exemplos"> 8 - Exemplos</A> </H1>

<P>
Os exemplos apresentados não são exaustivos, pelo que
nem todas as construções da linguagem são utilizadas.
<P>
O já habitual hello world:
<PRE>
public void prints(string s)
public integer entry (integer argc, string *argv, string *envp) {
  prints("olá pessoal!\n")
  entry := 0
}
</PRE>
<P>
O cálculo da função de Ackermann.
(Esta função tem um crescimento muito elevado pelo que nos
computadores actuais, mesmo utilizando <B>C</B>, os argumentos não
deverão exceder <TT>m=3</TT> e <TT>n=12</TT> para executar em
poucos segundos)
<PRE>
public void prints(string s)
public void printi(integer i)
public void println()

integer cnt := 0;
integer ackermann (integer m, integer n) {
  cnt := cnt + 1
  if m = 0 then ackermann := n+1
  else if n = 0 then ackermann := ackermann(m-1, 1)
  else ackermann := ackermann(m-1, ackermann(m, n-1))
}

public integer entry (integer argc, string *argv, string *envp) {
  if argc &gt; 2 then {
    printi(ackermann(atoi(argv[1]), atoi(argv[2])))
    prints(" #")
    printi(cnt)
    println()
  }
  entry := 0
}
</PRE>

Estes e outros exemplos podem ser obtidos na página do fénix.
<P>

<BR><HR>
<ADDRESS>
<I>Pedro Reis dos Santos</I>
<BR><I>2013-02-07</I>
</ADDRESS>
</BODY>
</HTML>
